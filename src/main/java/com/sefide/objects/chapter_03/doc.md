<aside>
💡

객체지향 패러다임의 핵심은 “역할”, “책임”, “협력” 이다.

</aside>

- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다. (인정인정 (-.-))

1. **협력(collaboration)**
    1. 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것
    2. 영화 예매 시스템을 돌아보기
        1. 다양한 객체들이 영화 예매라는 기능을 구현하기 위해서 **“메세지를 주고 받으면서”** 상호작용한다.
        2. 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.
            1. Movie의 행동은 요금을 계산하는 것이고
            2. 이 행동은 영화 예매하는 기능에 협력하기 위해 결정된 것이다.
            3. 즉, 협력을 위해 행동이 결정되고 행동으로 인해 객체의 상태가 결정된다. ⇒ 필요한 정보나 상태를 가짐 ex) policy
2. **책임(responsibility)**
    1. 객체가 수행하는 행동
    2. “하는 것”과 “아는 것” `p78`  ex) Movie : 영화 요금을 계산하고 영화 정보를 알고 있다.
    3. Information expert pattern(정보 전문가 패턴) : 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당한다. ⇒ 자율적인 객체를 만드는 가장 기본적인 방법

> “예매하라” 라는 ✉️ 전송
>

예매의 상영시간과 기본요금 정보를 가지고 있거나 이 소유자를 잘 알고 있는 객체(Screening)에게 책임을 할당한다!

> Screening  ✉️ 수신
>

예매 가격을 계산해야하는데?

> “가격을 계산해라” 라는 ✉️ 전송
>

예매 가격을 잘 알고 있는 객체(Movie)에게 책임을 할당한다!

> Movie  ✉️ 수신
>

뭐 이런식으로 협력에 필요한 메세지 찾고 객체 찾고의 반복스

d. **책임 주도 설계(Responsibility-Driven Design)** : 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식 `p84`

e. 메시지가 객체를 결정한다. 흠 => 중요하게 느껴진 부분

f. 행동이 상태를 결정한다. 흠 => 중요하게 느껴진 부분

객체의 행동이 아니라 상태에 초점을 맞추는 것은 캡슐화를 저해한다?

1. **데이터 주도 설계(Data-Driven Design) :** 객체의 내부 구현에 초점을 맞춰 설계
1. **역할(role)**
    1. 역할 : 어떤 특정한 협력 안에서 수행하는 책임의 집합
        1. ~~역할에 관해 고민하고 역할을 수행할 객체를 선택한다.. 그 객체가 메세지를 수신하여 역할을 수행하도록 한다..~~
        2. 역할이라는 개념에 집착하는 이유는? 유연하고 재사용 가능한 협력?
            1. “할인 요금을 계산하라” 라는 역할의 관점에서 보다보면 어떻게(금액 할인/비율 할인) 할인 요금을 계산할지를 추상화하게 됨 ⇒ DiscountPolicy가 탄생 응애
        3. 객체 vs 역할 (역할 모델링)
        4. 역할 and 추상화
            1. 중요한 정책을 상위 수준에서 단순화
            2. 유연한 설계

---

뭔가 1,2장에서 설명했던 것을 협력, 책임, 역할이라는 추상적인 개념으로 다시 한번 더 설명한 그런 너낌~