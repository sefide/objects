<aside>
💡

준비물 : 가벼운 마음 가짐 😏

</aside>

1. 영화 예매 시스템
    1. 영화, 상영
    2. 할인 조건
        1. 순번 조건
        2. 기간 조건
    3. 할인 정책
        1. 금액 할인 정책
        2. 비율 할인 정책
2. 객체지향 프로그래밍을 향해
    1. 협력, 객체, 클래스(class)
        1. 어떤 객체들이 필요한지 고민한다. 어떤 객체들이 어떤 상태와 행동을 가지는지 결정해야지 클래스를 설계할 수 있다.
        2. 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
    2. 도메인의 구조를 따르는 프로그램 구조
        1. 도메인(domain) : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
        2. 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 유사해야 한다.
    3. 클래스 구현하기
        1. 중요한 사실
            1. 객체는 상태와 행동을 함께 가져야 한다.
            2. 객체는 스스로 판단하고 행동하는 자율적인 존재
                1. 접근 통제 (캡슐화, 접근 제어(access control), 접근 수정자(access modifier))
                2. 인터페이스와 구현의 분리(separation of interface and implementation)
    4. 프로그래머의 자유
        1. 접근 제어 메커니즘 → 구현 은닉(implementation hiding) → **변경의 자유 ^*^!!!**
    5. 협력하는 객체들의 공동체
        1. 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다. ex) Money 오 굿.. **⇒ 배송비? 재고 수량? 에 활용할 수 있을까?**
        2. 협력(collaboration) : 어떤 기능을 구현하기 위해 객체들 사이에서 이뤄지는 상호작용
    6. 협력에 관한 짧은 이야기
        1. 메서드(method) : request 전송하고 response 수신받고 수신받은 메시지를 처리하기 위한 자신만의 방법
        2. [다형성](https://www.notion.so/2-1753dd4dd5b180619a3cdb736f5831f6?pvs=21) : 메서드와 메시지의 구분..?
3. 할인 요금 구하기 `p49`
    1. 할인 요금 계산을 위한 협력 시작하기
    2. 할인 정책과 할인 조건
        1. 상속(inheritance), 다형성, 추상화(abstraction)
            1. 인스턴스를 생성할 필요가 없다… 추상 클래스.. 후후 ex) DiscountPolicy
            2. ~~마치 당배/새배 회차 선택 로직?~~
        2. **템플릿 메서드 패턴(template method pattern) :** 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴
    3. 할인 정책 구성하기
4. 상속과 다형성 `p57`
    1. 컴파일 시간 의존성과 실행 시간 의존성
        1. 코드의 의존성과 (인스턴스) 실행 시점의 의존성이 서로 다를 수 있다.
        2. 이는 코드를 이해하기 어렵게 만들 수 있다.
    2. 차이에 의한 프로그래밍(programming by difference)
        1. 상속을 이용하면 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
        2. 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만든다.
    3. 상속과 인터페이스
        1. 업캐스팅(upcasting) : 자식 클래스는 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스 대신 사용될 수 있다.
    4. 다형성
        1. **다형성(polymorphism) :** 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될지는 메시지를 수신하는 객체의 클래스에 따라 달라지는 것! (기반 : [코드의 의존성과 (인스턴스) 실행 시점의 의존성이 서로 다를 수 있다. ](https://www.notion.so/1773dd4dd5b180a6a2c8ccc237a77424?pvs=21)) 상속 외에 다형성을 구현하는 방법은 여러가지다!
            1. 메시지와 메서드를 실행 시점에 바인딩한다 ⇒ 지연 바인딩(lazy binding),  동적 바인딩(dynamic binding)
        2. 예시)
            1. 메시지 : DicountPolicy의 calculateDiscountAmount
            2. 실행되는 메서드 : ~DiscountPolicy가 오버라이딩한 메서드
        3. 구현 상속(subclassing)과 인터페이스 상속(subtyping) : 코드의 재사용이 아닌 구현을 재사용하는 것을 목적으로 하자!
    5. 인터페이스와 다형성
        1. 구현을 공유할 필요 없을땐 인터페이스 타입 계층..
5. 추상화와 유연성 `p65`
    1. 추상화의 힘
        1. **도메인의 중요한 개념(상위 정책)을 설명할 수 있게 한다.**
        2. ?? : 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용!
    2. **유연한 설계**
        1. 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 좋지 않은 선택일 수 있다. ex) NoneDiscountPolicy
        2. 컨텍스트 독립성(context independency)
    3. 추상 클래스와 인터페이스 트레이드 오프
        1. **“여러분이 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 고민하고 트레이드오프하라”**
    4. 코드 재사용
        1. ?? : 상속 < 합성(composition)
            1. 상속은 캡슐화를 위반한다.
            2. 상속은 설계를 유연하지 못하게 만든다.
        2. 합성과 상속을 적절히 사용하자!