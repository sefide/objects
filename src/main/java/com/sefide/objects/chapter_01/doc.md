“이론 → 실무”

어떤 분야든 초기 단계에서는 아무것도 없는 상태에서 이론을 정립하기보다는 실무를 관찰한 결과를 바탕으로 이론을 정립하는 것이 최선이다.

> 소프트웨어 설계, 소프트웨어 유지보수에 있어서 이론이 실무를 앞서지 않기에 실무에 초점을 두고 설명할거임, 객체지향 패러다임에 대한 설명도 마찬가지
>

1. 티켓 판매 애플리케이션 구현하기
    1. 이벤트 당첨자 초대장 발송 구현
    2. 이벤트 당첨 관람객과 아닌 관람객을 다른 방식으로 입장시켜야 함.
2. 무엇이 문제인가
    1. 소프트웨어 모듈 목적
        1. 실행 중에 제대로 동작해야 한다. `충족`
        2. ***변경이 용이해야 한다.*** `미달`
        3. ***이해하기 쉬워야 한다. (의사소통)*** `미달`
    2. 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재 ex) 소극장이 관객의 가방을 열려고 함;
    3. 불필요한 사실을 많이 알아야 하는 점 ex) `Audience`가 `Bag`을 가지고 있고 `Bag` 안에 뭘 들고 있는지 알아야 한다.
    4. 변경에 취약한 코드인 점 ex) 관객이 현금이 아닌 신용카드를 가지고 있는 경우엔?
    5. 과한 의존성(dependency) ⇒ 결합도(coupling)가 높다.
        1. 객체 사이의 의존성이 변경과 관련되어 있다.
        2. 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야 한다.
3. 설계 개선하기
    1. 자율성을 높이자 ⇒ 이해하기 쉽고 유연한 설계
        1. **캡슐화(encapsulation)** : 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것 for 변경 용이성
        2. **인터페이스(interface)** ticketSeller와 **구현(implementation)**으로 나누고 인터페이스만을 공개하는 것이 결합도를 낮추는 방법
    2. 어떻게?
        1. 캡슐화와 응집도
            1. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에서 위임하는 객체 ⇒ **응집도(cohesion)가 높다**
        2. 절차지향과 객체지향
            1. **절차적 프로그래밍(Procedural Programming)** : 프로세스(Process)와 데이터(Data)를 별도의 모듈에 위치시키는 방식, 프로세스가 필요한 모든 데이터에 의존해야 한다.
            2. **객체지향 프로그래밍(Object-Oriented Programming)** : 프로세스와 데이터가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
        3. 책임의 이동(Shift Of Responsibility)
            1. 각 객체에 적절하게 책임이 분배되어야 한다.
    3. 자율성을 높이다가 결합도가 상승한 경우 ex) TicketOffice ↔ Audience TradeOff ? **흠…..** `p33`
    4. 의인화 (anthropomorphism) : 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙 by 레베카 워프스브록
4. 객체지향 설계
    1. 설계란 코드를 배치하는 것이다. **좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계.. 후후 하하 벤더플렉스 도착보장일 내려주는 함수 떼어두기.. 후후후**
    2. **코드 수정을 회피하려는 가장 큰 원인은 버그를 추가할지도 모른다는 불확실성에서 오는 두려움.. 맞음..**
    3. **객체지향 설계를 통해 변경에 유연한 코드를 만들자**